import queue
from functools import partialmethod
from concurrent.futures import Executor, as_completed, ThreadPoolExecutor

import grpc

class ServiceWrapper:
    def __init__(self, service_stub):
        self._stub = service_stub
        meths = []
        # I'm so sorry!
        with grpc.insecure_channel('localhost') as ch:
            serv = service_stub(ch)
            for name in dir(serv):
                if name.startswith('_'):
                    continue
                if callable(getattr(serv, name)):
                    meths.append(name)
        # Now we know the names of all the non-private methods. But at
        # what cost?

        for name in meths:
            bind_call = partialmethod(ServiceWrapper._run_rpc, name).__get__(self)
            setattr(self, name, bind_call)

        return

    def _run_rpc(self, method, channel, request):
        stub = self._stub(channel)
        reply = getattr(stub, method)(request)
        return reply


class grpcPoolExecutor(Executor):
    """
    A concurrent.futures.Executor wrapper for gRPC requests
    """
    def __init__(self, max_workers, channels, service_stub):
        """max_workers - The maximum number of outstanding requests

        channels - list of gRPC channels used to service the requests.
        They need not be open and may be shared between different
        pool. They will be opened when the pool is constructed if not
        already.

        service_stub - grpc stub for the service being called (as
        generated by `protoc`). Each pool is bound to a single
        service. To call multiple services, construct mutliple pools.
        They may share channels between them.

        The pool is *not* threadsafe. It is not safe to call its
        methods outside the thread the created it.

        """
        self._channels = channels
        self._stub = service_stub
        self._is_running = False
        self._channel_queue = queue.Queue()
        self._pool = ThreadPoolExecutor(max_workers)
        # connect to servers
        self._connect()
        self._tasks = []

    def _connect(self, timeout=None):
        "Connect all channels"

        def do_connect(channel):
            return grpc.channel_ready_future(channel)

        for ch,fut in [(c, do_connect(c)) for c in self._channels]:
            # As the channels become ready, add them to the queue of
            # available channels
            self._channel_queue.put(ch)
            self._is_running = True
        return

    def submit(self, fn: ServiceWrapper, request):
        """Submit a callable RPC method to be executed. Returns a future that
will eventually have the results of the RPC.

        fn is not actually every called. What matters is that it have
        the /name/ of a method of the service stub provided when the
        pool was constructed.

        fn - A callable binding to a method of the provided service
        stub. The should be a method of a `ServiceWrapper` bound to
        the service. N.B. the methods of `ServiceWrapper` take two
        arguments, not one (the channel and the request).

        request - a gRPC request to be passed into the method

        Because of the required signature of fn, passing a function
        into `submit` has a different effect than calling it normally.
        This is an unfortunate pathology.

        """
        if not self._is_running:
            raise RuntimeError("cannot schedule new futures after shutdown")

        def submit_task():
            chan = self._channel_queue.get()
            if chan is None:
                response = concurrent.futures.Future()
                response.set_exception(RuntimeError("pool closed while task in progress"))
                return response
            response = fn(chan, request)
            self._channel_queue.put(chan)
            return response

        fut = self._pool.submit(submit_task)
        self._tasks.append(fut)
        fut.add_done_callback(lambda r: self._tasks.remove(fut))
        self._tasks.append(fut)

        return fut

    def shutdown(self, wait=True, cancel_futures=False, close_channels=False):
        """Signal the executor that it should free any resources it is using
        once the currently outstanding futures are done executing.

        If `wait` is True, this method will block until they complete.

        If `cancel_futures` is True, this method will cancel any
        futures that have not yet started running.

        If `cancel_futures` and `wait` are both True, all pending
        futures will be canceled while those already started will be
        allowed to complete.

        If `close_channels` is True the provided gRPC channels will be
        signlaled to close once all in progress tasks are allowed to
        complete

        """
        self._is_running = False
        incomplete_tasks = [ f for f in self._tasks if not f.done() ]
        running_tasks = [ f for f in self._tasks if f.running() ]

        # If both cancel_futures and wait are True, all futures that
        # the executor has started running will be completed prior to
        # this method returning. The remaining futures are cancelled.
        if wait and cancel_futures:
            for f in as_completed(running_tasks):
                pass

        if cancel_futures:
            for fut in self._tasks:
                if fut not in running_tasks:
                    fut.cancel()

        if wait:
            for f in as_completed(self._tasks):
                pass

        if close_channels:
            self._channel_queue.put(None)
            for ch in iter(self._channel_queue.get, None):
                ch.close()

        while not self._channel_queue.empty():
            try:
                ch = self._channel_queue.get_nowait()
            except queue.Empty:
                continue
            if ch is not None:
                self._channel_queue.put(None)

        return
